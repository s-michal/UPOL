(define mlist
  (lambda args
    (if (null? args)
        '()
        (mcons (car args) (apply mlist (cdr args))))))


(define length
  (lambda (l)
    (if (null? l)
        0
        (+ 1 (length (mcdr l))))))

(define cycle!
  (lambda (l)
    (let iter ((aux l))
      (if (null? (mcdr aux))
          (set-mcdr! aux l)
          (iter (mcdr aux))))))

(define seznam (apply mlist '(1 2 3)))
seznam
(cycle! seznam)
seznam

(define cyclic?
  (lambda (l)
    (let test ((rest (mcdr l)))
      (cond ((null? rest) #f)
            ((eqv? rest l) #t)
            (else (test (mcdr rest)))))))

(define s (apply mlist '(4 5)))
(cyclic? s)
(cyclic? seznam)

(define x (apply mlist '(1 2 3)))
(set-mcar! (mcdr x) x)
x

(define depth-cyclic?
  (lambda (l)
    (let ((found '()))
      (let test ((l l))
        (if (pair? l)
            (if (memq l found)
                #t
                (begin
                  (set! found (cons l found))
                  (or (test (car l))
                      (test (cdr l)))))
            #f)))))

(depth-cyclic? x)
(cyclic? x)

(define consd
  (lambda (elem dlist)
    (let ((new-cell (mcons elem (mcons '() dlist))))
      (if (not (null? dlist))
          (set-mcar! (mcdr dlist) new-cell)
          new-cell))))

(define s (consd 'c (consd 'd '())))
s

(define make-box
  (lambda (value)
    (lambda (signal . newvalue)
      (cond ((equal? signal 'get) value)
            ((equal? signal 'set)
             (set! value (car newvalue)))
            (else (error "WRONG INput"))))))

(define val (make-box 10))
(val 'get)
(val 'set 500)
(val 'get)


(define-macro if-new
  (lambda (first second . rest)
    `(if ,first
         ,second
         (begin #f ,@rest))))

(if-new #f 20 160)


(define-macro AD
  (lambda args
    (if (null? args)
        #t
        (if (null? (cdr args))
            (car args)
        `(let ((result ,(car args)))
           (if result
               (AD ,@(cdr args))
               #f))))))

;(AD 10 result 2 result)

(define-macro andd
  (lambda args
    (if (null? (cdr args))
        (car args)
        `(if ,(car args)
             (andd ,@(cdr args))
             #f))))

;(andd 1 2 3 4 5)

(define-macro LETS
  (lambda (sym assign . body)
    `((lambda ()
        (define ,sym
          (lambda ,(map car assign)
            (begin ,@body)))
        (,sym ,@(map cadr assign))))))

;(member 10 '(1 2 3 10))

(define-macro while
  (lambda (condition . body)
    `(let loop ((last (void)))
       (if ,condition
           (loop (begin ,@body))
           last))))

(let ((x 0))
  (while (< x 10)
         (begin
           (set! x (+ x 1))
           (list x))))


(define-macro for
  (lambda (init condition incr . body)
    `(begin
       ,init
       (let loop ()
         (if ,condition
             (begin ,@body
                    ,incr
                    (loop)))))))


(let ((i 0)
      (result 0))
  (for (set! i 5)
    (> i 0)
    (set! i (- i 1))
    (display (list "Stav: " i result))
    (newline)
    (set! result (+ result 1)))
    (display (list "Koncovy: " i result))
    (newline))


(define-syntax and
  (syntax-rules ()
    ((and) #t)
    ((and test) test)
    ((and test1 test2 ...)
     (if test1 (and test2 ...) #f))))


(define-syntax OR
  (syntax-rules ()
    ((OR) #f)
    ((OR test) test)
    ((OR test1 test2 ...)
     (if test1 test1 (OR test2 ...)))))

(OR #f 2 3)


(letrec-syntax
    ((A (syntax-rules ()
          ((A) #t)
          ((A test) test)
          ((A test1 test2 ...)
           (if test1 (A test2 ...) #f)))))
  (A 1 2 3))